{
  "book-review-crime-punishment": {
    "title": "Book Review - Crime & Punishment",
    "date": "Dec 16, 2025",
    "content": "Crime & Punishment by [Fyodor Dostoevsky](https://en.wikipedia.org/wiki/Fyodor_Dostoevsky) is an absolutely incredible novel. I was captivated the entire time and was practically screaming during the intense parts. It's emotionally devastating, but also intellectually demanding, with a strong philosophical undertone.\n\nThe story follows Raskolnicov, a destitute former student in 19th-century St. Petersburg who convinces himself that murdering a pawnbroker is morally justified for the \"greater good\". He believes \"extraordinary individuals\" may transgress moral law if the outcome benefits humanity.\n\nBut once the crime is committed, the theory collapses. He feels neither liberated nor righteous. Instead, he begins to unravel. Guilt, paranoia, and psychological turmoil consume him as police pressure mounts and his relationships with family and friends force him to confront what he has become. The novel ends not with vindication, but with confession to the police, exile to Siberia, and the beginning of a painful moral rebirth.\n\nThe murder scene is especially striking because of how unplanned and dissociated it feels. Raskolnikov doesn't act like a calculating mastermind. He moves almost unconsciously, as if swept along by momentum rather than intention. The act feels less like a controlled execution of a plan and more like a psychological collapse.\n\nThe novel's central tension is clear: Raskolnikov believes he can justify the murder through reason, yet he cannot live with it. His suffering exposes a deep disconnect between abstract moral reasoning and the human moral conscience. Even if an act can be justified on paper, it may still violate something fundamental in us. Dostoevsky's challenge is implicit but devastating: if a moral theory cannot be endured psychologically, in what sense is it true at all?\n\nThat's what makes the book feel timeless. Most people believe they're moral, but for many this confidence rests on moral theory rather than lived testing. Imagine a father whose child has cancer and the only way to raise money for treatment in time is to sell drugs - at that point, moral theory loses its clarify. Dostoevsky shows that morality cannot be known with certainty in advance. It is revealed only under pressure, where even our most confident ethical beliefs begin to break down."
  },
  "functional-programming-with-typescript": {
    "title": "Functional Programming with TypeScript",
    "date": "Sep 16, 2024",
    "content": "Functional programming (FP) focuses on creating code that is predictable, easy to understand and resilient to bugs. At its core, FP revolves around key principles such as immutability, pure functions and higher-order functions. In this article, we'll delve into these fundamental concepts and illustrate how we can refactor our code to embrace a FP style.\n\n## Immutability\n\nImmutability means that once you create a data structure (like an array or object), you don't change it. Instead of modifying data, you create new versions of it. This makes code easier to understand and less prone to bugs because you avoid unexpected side effects. For example:\n\n```ts\nconst numbers: readonly number[] = [1, 2, 3];\n// numbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'\n\nconst newNumbers = [...numbers, 4]; // create a new array with an added element\nnewNumbers; // [1, 2, 3, 4]\n```\n\nThe original `numbers` array remains unchanged. Instead, we use the spread operator to create a new array, which maintains immutability.\n\n## Pure Functions\n\nA pure function always produces the same output for the same input and does not have side effects (like changing a global variable or modifying an external object). This predictability makes pure functions easy to test and debug.\n\n```ts\nconst add = (a: number, b: number): number => a + b;\nadd(2, 3); // 5\nadd(2, 3); // 5\nadd(2, 3); // 5\n```\n\nNo matter how many times you call `add` with the same arguments, it always returns the same result and does not alter any external state.\n\n## First-Class Functions\n\nIn TypeScript, functions are first-class citizens. This means you can treat functions like any other value - they can be passed as arguments, returned from other functions and assigned to variables.\n\n```ts\n// function that takes another function as an argument\nconst applyFunction = <T>(value: T, func: (input: T) => T): T => func(value);\n\n// function to be passed\nconst square = (x: number): number => x * x;\n\n// using applyFunction to apply square to a value\nconst result = applyFunction(5, square);\nresult; // 25\n```\n\n`applyFunction` demonstrates how functions can be passed around and applied in different contexts.\n\n## Higher-Order Functions\n\nHigher-order functions are your best friends in FP. They either take other functions as arguments or return functions. For example, map is a higher-order function that applies a given function to each element of an array:\n\n```ts\nconst addEmoji = (str: string): string => `${str} ðŸ˜Š`;\nconst result = ['hello', 'world'].map(addEmoji); // ['hello ðŸ˜Š', 'world ðŸ˜Š']\n```\n\nThe `map` function applies `addEmoji` to each element of the array, showcasing how higher-order functions can transform data.\n\n## Function Composition\n\nFunction composition involves combining multiple functions to create a new function. This is a core concept in functional programming that allows for cleaner and more modular code.\n\n```ts\nconst compose =\n  <T, U, V>(f: (x: T) => U, g: (x: U) => V) =>\n  (x: T): V =>\n    g(f(x));\n\nconst double = (x: number): number => x * 2;\nconst increment = (x: number): number => x + 1;\n\nconst doubleThenIncrement = compose(double, increment);\ndoubleThenIncrement(3); // 7\n```\n\nHere, `compose` creates a new function `doubleThenIncrement` by combining `double` and `increment`, demonstrating how composition can streamline complex operations.\n\n## Refactoring to Functional Programming Style\n\nSuppose we have an array of transactions and we want to perform a series of transformations on this data. The transformations are:\n\n1. Filter transactions that are completed.\n2. Calculate the total amount for each transaction.\n3. Format the total amount as a currency string.\n4. Sort the transactions by the formatted total amount.\n\nHere's the sample data we'll work with:\n\n```ts\ninterface Transaction {\n  id: number;\n  amount: number;\n  completed: boolean;\n}\n\nconst transactions: Transaction[] = [\n  { id: 1, amount: 200, completed: true },\n  { id: 2, amount: 150, completed: false },\n  { id: 3, amount: 300, completed: true },\n  { id: 4, amount: 250, completed: true },\n];\n```\n\n#### Imperative (Traditional) Approach\n\nHereâ€™s how you might traditionally approach this problem using imperative code:\n\n```ts\nfunction processTransactions(transactions: Transaction[]): string[] {\n  const completedTransactions: Transaction[] = [];\n  for (const transaction of transactions) {\n    if (transaction.completed) {\n      completedTransactions.push(transaction);\n    }\n  }\n\n  const totals: number[] = [];\n  for (const transaction of completedTransactions) {\n    totals.push(transaction.amount);\n  }\n\n  const formattedTotals: string[] = [];\n  for (const total of totals) {\n    formattedTotals.push(`$${total.toFixed(2)}`);\n  }\n\n  formattedTotals.sort();\n  return formattedTotals;\n}\n\nconst result = processTransactions(transactions);\nresult; // ['$200.00', '$250.00', '$300.00']\n```\n\n#### Functional Programming Approach (with Composition)\n\nTo refactor this into a more functional approach, weâ€™ll use function composition to chain our transformations together. Weâ€™ll create smaller, reusable functions and compose them to achieve the final result.\n\n```ts\nconst filterCompleted = (transactions: Transaction[]): Transaction[] =>\n  transactions.filter((transaction) => transaction.completed);\n\nconst extractAmounts = (transactions: Transaction[]): number[] =>\n  transactions.map((transaction) => transaction.amount);\n\nconst formatAsCurrency = (amount: number): string => `$${amount.toFixed(2)}`;\n\nconst formatAmounts = (amounts: number[]): string[] =>\n  amounts.map(formatAsCurrency);\n\nconst compose =\n  <T, U, V>(f: (x: T) => U, g: (x: U) => V) =>\n  (x: T): V =>\n    g(f(x));\n\nconst processTransactions = compose(\n  (transactions: Transaction[]) =>\n    formatAmounts(extractAmounts(filterCompleted(transactions))),\n  (formattedTotals: string[]) => formattedTotals.sort()\n);\n\nconst result = processTransactions(transactions);\nresult; // ['$200.00', '$250.00', '$300.00']\n```\n\nIn this refactored code, we use function composition to chain our operations in a clean and modular way. Each function handles a specific part of the process, making the code easier to understand and maintain.\n\n## Final Reflection\n\nAdopting functional programming principles in TypeScript can sharpen code reliability and maintainability. Ultimately, creativity remains your most important tool - use these principles to guide your design and let creativity drive innovative solutions."
  }
}

import type { TBlogPost } from "../../types";

export const blogPosts: TBlogPost[] = [
  {
    id: 0,
    title: "Functional Programming with Typescript",
    date: "Aug 3, 2024",
    content:
      "Functional programming is all about immutability, pure functions, and higher-order functions. By leveraging these principles alongside TypeScriptâ€™s strong typing, you can write code that is clearer, more reliable, and easier to maintain.\n\n## Immutability\nImmutability means that once you create a data structure (like an array or object), you don't change it. Instead of modifying data, you create new versions of it. This makes code easier to understand and less prone to bugs because you avoid unexpected side effects. For example:\n\n```ts\nconst numbers: readonly number[] = [1, 2, 3];\n// numbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'\n```\n\nHere, `numbers` is immutable due to the `readonly` keyword. We can use `readonly` arrays and objects to enforce immutability. Instead of changing the original array, you create `newNumbers` by spreading the old array and adding a new element. This practice helps prevent unintended side effects and makes your code more predictable.\n\n## Pure Functions\nA pure function always produces the same output for the same input and does not have side effects (like changing a global variable or modifying an external object). This predictability makes pure functions easy to test and debug. For example:\n\n```ts\nconst add = (a: number, b: number): number => a + b;\nadd(2, 3); // 5\nadd(2, 3); // 5\n```\n\nNo matter how many times you call add with the same arguments, it always returns the same result and does not alter any external state.\n\n## First-Class Functions\nIn FP, functions are first-class citizens. This means you can treat functions like any other value - they can be passed as arguments, returned from other functions, and assigned to variables.\n\n```ts\n// Function that takes another function as an argument\nconst applyFunction = <T>(value: T, func: (input: T) => T): T => func(value);\n\n// Function to be passed\nconst square = (x: number): number => x * x;\n\n// Using applyFunction to apply square to a value\nconst result = applyFunction(5, square);\nconsole.log(result); // 25\n```\n\nIn this example, `applyFunction` takes a value and a function as arguments, then applies the function to the value. This demonstrates how you can pass functions around just like other values.\n\n## Higher-Order Functions\nHigher-order functions are your best friends in FP. They either take other functions as arguments or return functions. For example, map is a higher-order function that applies a given function to each element of an array:\n\n```ts\nconst addEmoji = (str: string): string => `${str} ðŸ˜Š`;\nconst result = ['hello', 'world'].map(addEmoji); // ['hello ðŸ˜Š', 'world ðŸ˜Š']\n```\n\n## Function Composition\nFunction composition involves combining multiple functions to create a new function. This is a core concept in functional programming that allows for cleaner and more modular code.\n\n```ts\nconst compose = <T, U, V>(f: (x: T) => U, g: (x: U) => V) => (x: T): V => g(f(x));\n\nconst double = (x: number): number => x * 2;\nconst increment = (x: number): number => x + 1;\n\nconst doubleThenIncrement = compose(double, increment);\ndoubleThenIncrement(3); // 7\n```\n\nHere, `compose` creates a new function `doubleThenIncrement` by combining `double` and `increment`. Function composition enhances code readability and reuse.\n\n## Conclusion\nFunctional programming is like crafting the perfect hotdog - every component plays a crucial role. Though at the end of the day, creativity is your most important tool. Use these principles to enhance your coding, and let your creativity drive innovative solutions.",
  }
];
